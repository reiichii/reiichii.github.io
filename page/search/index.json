[{"content":"平日夜の時間を使ってちょこちょこprivate-isuでパフォーマンス改善の勉強をしていました。\n大半やISUCON本や他の方のブログを参考にしたものなので、パフォーマンス改善面で真新しいことはやっていません。自分の整理\u0026amp;復習目的でやったことを書こうと思っていたのですが、試行錯誤ログが酷すぎて復習ブログ書くのが困難だったので、一旦作業ログとしてソースコードだけ残します。\n4月はプライベートが忙しくなりそうなのと、ちょっと別のことをやりたくなったので、落ち着いたら復習がてら解きなおして再度まとめたい..。\nhttps://github.com/reiichii/isucon-private-isu\n参考 ISUCON過去問題の環境を「さくらのクラウド」で構築する | さくらのナレッジ 達人が教えるWebパフォーマンスチューニング 〜ISUCONから学ぶ高速化の実践 | Amazon ISUCONの素振りで private-isu をやってGo実装で32万点までひとまず行った | stefafafan の fa は3つです ","date":"2023-04-09T10:50:51+09:00","permalink":"https://reiichii.github.io/post/2023-04-09-11/","title":"catatsuy/private-isuのパフォーマンス改善（max10万点程度）"},{"content":"『プログラマー脳 ~優れたプログラマーになるための認知科学に基づくアプローチ』と言う本を読んだ時のメモです。\n積み本そっちのけで読む pic.twitter.com/6XuNOV4aXs\n\u0026mdash; れ (@reiichii01) February 27, 2023 きっかけ Goを勉強している時や仕事の中で、なんとなくコーディングに苦手意識がありました。そんな折にたまたまこの本を知って、息抜きがてら読んでみました。\nざっくりとした感想 自分の場合、脳への負荷が高くなると思考が停止してしまうことが多いのですが、そんな時に今の作業や状態をなるべく小さい単位で把握できると、どこが課題なのかどう対処できそうか考えを進めることができるので、それを実践していきたいと改めて思いました。本の各章に様々な課題に役に立ちそうなtipsが残っていたので、そういった状況に直面したタイミングで、使えそうだなと思ったものをちゃんと思い出せるようにしたいです。\n本に出てくる「チャンク化」や「メンタルモデル」のなどは、コーディング以外のところではやっている自覚はあって、ただ自分ではそういうことをしているという自覚はなかったので、無意識だったものを言語化して把握することができました。\n他にもオンボーディングの話や、初学者と熟練者の取り組み方の比較など書いてあったので、自分よりも若手の人に教えたりする機会にも役に立ちそうな内容が多く含まれていました。\n複数人に対してどんな風に変数の命名をするか課題を出して結果を比較するなど、プログラミング関連の研究事例が多数紹介されていたのも面白かったです。世の中にこんな研究している人たちがいることを知って目から鱗でした。\n内容 とりわけ印象に残っているところを中心に、自分が思い出す用途のものです。ただ内容をしっかり説明できるほど理解はできていないので、一旦そう言うものがあるのかも程度に留め、必要に応じて該当箇所を読み返したいです。\n第1章 コードをよりよく理解するために この章ではコーディング時に発生する認知負荷についてどんなものがあるのか、またそれらがどう影響し合っているのか、それらを踏まえてコードを読みやすくするためにできる工夫などが書かれていた。\nコードを読む時の認知負荷 知識不足 情報不足 処理能力の不足 記憶のチャンク化 ビーコンなど、記憶を容易にする工夫をすると良い 負荷が高いと感じる時に、何によるものなのか自分が把握できると良いのかもと思った。\n第2章 コードについて考える この章では第1章の認知負荷の話を踏まえて、コードをより理解するためのアプローチ方法について書かれていた。\n変数の役割11パターン 固定値 ステッパー：ループ処理の際に使われるiのようなもの フラグ ウォーカー：ステッパーと同様にデータを走査する際に使用されるが、ステッパーのように何が入るか予測しにくいもの。配列のインデックスだったり、ポインタだったり 直近の値の保持者：例えばファイルから読み込んだ行など 最も重要な値の保持者：反復処理の中などで目的の値を保持するもの 収集者：データを一つの変数に集約させている時に使うもの コンテナ：リストや配列など、複数要素を保持するもの フォロワー：アルゴリズムなどで、前や次の値を保持して、他の変数とセットで利用されるもの オーガナイザー：値を並べ替えたり、異なる形式で保存するためだけに使われるもの テンポラリ：短期間だけ使われるもの コードを読む際にも適用可能な文書理解の戦略 活性化：関連する事柄を積極的に考え、過去の知識を活性化させる 監視：理解度を把握し続ける 重要性の判断 推論 可視化 自問自答 要約 メンタルモデル より良い変数名のための3ステップ 命名に含める概念を選択する 概念を表す単語を選択する 単語を使って命名を行う 変数の役割11パターンは自分考えたことなかったけど、言われてみれば役割は何パターンかに集約されそう。\n第3章 より良いコードを書くために この章では理解しやすいコードを書くにはどうするか、またその逆として理解しにくいコードにはどういう特徴があるか、といった内容が書かれていた。\nコードの臭い 「巨大なクラス」や「長過ぎるメソッド」など、リファクタリング本で取り上げられているものが紹介されていた 範例（work example）。問題解決能力を養うには、公式だけではなく、公式を使ってどうやって解いたかも合わせて教えてもらったグループの方が点数が高くなる傾向にあると言う教育系の研究事例がある。 リファクタリング本は読もうと思っていて積んでいたので、内容を少し知れて参考になった。\n今までの章を読んでこの章を読むと、分かりやすい命名によって受けられる恩恵の大きさを再認識できた気がする。\n第4章 コーディングにおける共同作業 この章では開発者個人からさらに視野を広げて、チームで開発する際に新しい人が参画しやすくする方法などについて書かれていた。\nプログラミングの中の様々な活動\n転写 探索 理解 検索 増強：検索・理解・転写を組み合わせて新しい機能を作ること コードの理解のしやすさの指標\nエラーの発生しやすさ 一貫性 拡張性 隠された依存関係 暫定性 粘性 段階的評価 役割表現力 マッピングの近接度 ハードな心的操作 副次的表記 抽象化 視認性 表記法の認知特性（cognitive dimentions of notation）と言うものを、コードを対象に拡張したもの。ただしこれらは全部を満たせれば良いと言うものではなく、トレードオフの関係になるものもある。\n新人のオンボーディングにあたって、認知負荷が高いことを覚えておく必要がある。熟練者は習得にかかった負荷を忘れてしまうもの\nエンジニア1年目の自分は熟練のプログラマーは頭の中で全てコーディングを完結させているものだと思っていたので、1年目の自分にこれを教えてあげたかった。\n","date":"2023-04-09T10:27:16+09:00","permalink":"https://reiichii.github.io/post/2023-04-09-10/","title":"プログラマー脳 ~優れたプログラマーになるための認知科学に基づくアプローチ を読んだ"},{"content":"Software Design2月号で特集されていたドメイン駆動設計入門を読んだ時のメモです。\nきっかけ 直近のタスクで作ったコードの設計がなんとなくいまいちで、どうすればもっとよくできていたのか悩んでいました。 また少し読んでいたGoの本で出てきたAPIのリポジトリ構成の設計思想がクリーンアーキテクチャやDDDがベースになっているもので、この辺り理解を深めたいなと思っていました。 そんな折にたまたま雑誌を見つけたので買って読んでみた次第です。\nざっくりとした感想 ちゃんと学びたいのであれば本当は原点の本にあたるべきなのですが、分厚く内容も古いため、雑誌の方が効率よく概要を把握できたような気がします。 特に本では説明されていない、クリーンアーキテクチャのような他の設計との関係性など、実用的な追記されているのが良いところでした。\n前半1~3章（概要・ドメインモデルの作り方・分散アーキテクチャの設計パターン）まではよかったのですが、4章（開発事例）に関しては説明が腑に落ちなかったり、事例に結果が伴っていなかったりと物足りなさは感じました。 とはいえ前半3章だけでも十分に読む価値はありました。\n思想みたいなものは大分把握できたと思うのですが、実業務にうまいこと導入するところに関してはまだイメージが湧かないので、もう少しいろんな他社事例を見てみれたらと思います。\n余談ですが、分散アーキテクチャの章で紹介されていた書籍「ソフトウェアアーキテクチャ ノードパーツ」読みたい。\n内容 主に復習\u0026amp;自分が思い出す用。第4章は割愛し、第5章（用語まとめ）は織り交ぜて要所要所に混ぜ込んだ。\n第1章. ドメイン駆動設計とは 根本の考え方について説明されている章。原点本の内容ベースだが、それにアプリケーション開発・オブジェクト指向・アジャイル開発と絡めた説明を筆者が追記している。\n前提としている考え方 事業の存続と発展 それには、成長と変化するソフトウェアが必要になる それを実現するためには、複雑な業務ロジックに焦点を当てる必要がある そのためにドメインモデルを使う ドメイン なんらかのルールに基づいて管理されている範囲 ソフトウェアが対象とする領域 ドメイン駆動設計は、ソフトウェアV字モデルの最上位と最深部を強く関連づけることを目標とし、事業活動が発展し、変化を繰り返しながら存続していくことに貢献することを目指している ドメインモデル 事業の要点を抜き出してわかりやすくしたもの 活用方法として以下がある 業務知識の理解を深める 用語がバラバラになる問題に対し、同じ言葉で開発できるようにする 知識豊富な設計 重要な業務ルールを見極め、関係性を整理するためにドメインモデルを作っていくこと 深いモデル 見落としに気付けたり、暗黙的な枠組みを明示的に表現できるようになったドメインモデル これら二つは目指す方向性の認識合わせに必要 モデルと実装を結びつけるためのパターン 3層構造 ポート\u0026amp;アダプター クリーンアーキテクチャ 3は完成コストが高く、それを簡略化したものが1や2という見方もある。上記3つの基本原則は同じ 分離方法 業務ロジックとそれ以外のクラスを分離する 業務ロジックを表現するクラスだけを、ドメインモデルに置く 必要であれば両方を合成するクラスを作る（これはドメインモデルの外に置く） これらが混在することはよくあるので、都度リファクタリングをしていく 第2章. ドメインモデルを理解しよう ドメイン駆動設計の中心となるドメインクラス設計のやり方について、原点本にも出てくる貨物運搬の予約フローを例にモデルに落とし込むやり方が解説されている。\n業務ロジックを記述する方法3つ トランザクションスクリプト 入出力手順中心 ▲同じ計算が異なるトランザクションスクリプトに点在。関連する業務ルールが点在しがちになる。複雑なルールの記載は難しい ドメインモデル 業務ロジックとデータ参照を分ける このデータ参照部分をアプリケーションクラス・ユースケースクラスと言ったりする テーブルモジュール CRUDの中に必要に応じて業務ロジックを埋め込む ▲複数のテーブルをまたぐロジックは埋め込めない 事業活動のモデルを作る観点として、以下3つがある 観点 プロセス フロー図やumlのアクティビティ図に起こす この図ではルールの存在を明示できない データ よくあるのは、イベントとリソースに分けてモデリングするやり方 ルール 業務ルールを表現する概念をクラスで表現しながら、業務ルールに基づく計算判断のロジックの置き場所としてメソッドを作る モデル設計の構成要素 エンティティ 個別に認識できる実態。管理番号を持つ何か。クラスの有力候補 業務ルールを見つける方法として、エンティティを「イベント」「短命なリソース」「長命なリソース」に分けるやり方がある イベントには2種類のルールが関連する イベント発生に関するルール（許可・禁止） 行動ルール（記録・通知など） 値オブジェクト 業務ルールに基づく計算判断に使う属性を発勁んし、クラスとして表現するパターン 値オブジェクトに注目することで、値を使う業務ルールが見つかる コレクションオブジェクト 配列・集合・写像などインスタンス変数としてもち、それを使う操作ロジックを同じクラスに集める 区分オブジェクト 場合分けを整理するのに使う。Enumで表現されるような モジュール エンティティやオブジェクトなど、数あるクラスをわかりやすく整理するパターン。パッケージや名前空間となる 第3章. 分散アーキテクチャとドメイン駆動設計 分散アーキテクチャとドメイン駆動設計がどう絡むかを、原点本ベースにした内容が紹介されている。\n単一モデル 従来のソフトウェア設計では、事業活動全体をこれで考えていた。しかしそれによって全体の構造が固定され、柔軟性や発展性が失われていった 分散モデル 自立して活動する複数の構成要素が動的につながって、ネットワークを構成している ドメイン駆動設計が提供する分散アーキテクチャのモデルには、以下の3パターンがある 境界づけられたコンテキスト 1つのドメインが対象とする範囲を限定するアプローチ これによって、業務の目的や関心事が異なる領域を切り分ける。ユビキタス言語の適用範囲になる コンテキスト(文脈)：言葉の意味は文章の前後によって決まる。ドメインモデルを作るときは言葉の意味が同じになる範囲を切り分ける、が発想元 必ずしも分散アーキテクチャの範囲となるわけではない コンテキストマップ 1の中だけで意味を持つ複数のドメインモデルをどう繋げるかを検討するパターン コアドメイン 2が増えた時に、複雑な全体の中で中核になる要素に焦点を合わせ、全体に秩序を生み出す マイクロサービス化する際に考えなければいけないこと サービス間の繋ぎ方 通信はDBに比べて遅く不安定なので、検知やリトライの仕組みが必要になる データの共有 同じデータを参照する仕組みのやり方色々 必要な情報を都度問い合わせる 共有のためのサービスを作る 情報を複製（キャッシュ）する コンテキストマップを複雑にする要因はチーム間の関係性 関係性のパターン 対等 パートナーシップ 共有カーネル 偏りがある 顧客と供給者 順応者 腐敗防止層 公開ホストサービス 断絶した関係 サービス間調整のやり方 API仕様の公開 テスト仕様の公開 仕様を一種の契約と見做して、双方が満たすことに責任を持つ テスト環境の提供 提供側の負担は大きいが、問題の早期発見につながる コアドメインに集中する 事業領域の全体にドメイン駆動設計のやり方を適用するのは、現実的ではないので、集中すべきところを絞る 集中すべきところ 業務プロセスやルールが複雑な箇所 独自性のある箇所 コアドメイン以外の対処法 既製品を使う。契約管理など イージーオーダー フルオーダー 進化する秩序 コンテキストやつなぎ方は日々進化していくため、秩序を整えていく必要がある 責務のレイヤー 上記を実現する手段の一つ。1つのドメインの中でパッケージの役割を分類し、パッケージ間の依存関係を整理する ドメインモデルを中核としたアプリケーションを動かすパターン ユースケース（アプリケーション） アプリケーションが必要とする計算判断を「集約」が提供するが、それを使って計算判断を実行する役割のクラス ファクトリー 複雑な集約を生成する役割のクラス リポジトリ ユースケースが記録や参照に使う役割のクラス ","date":"2023-02-27T14:52:15+09:00","permalink":"https://reiichii.github.io/post/2023-02-27-15/","title":"ドメイン駆動設計入門(SoftwareDesign2023年2月号)を読んだ"},{"content":"2/28(土)に『ポーズの定理』イラスト講座に参加してきたのでその記録です。\n一番印象に残ったことは、人体を書く時はそのポーズのフェーズも意識する必要があると知れたことでした。それにより重心がどっちに向いているのか、重心の向く方向によって首や手首や胴体の捻りが生じ、それを描くことで固くならないリアリティのあるポーズに繋がります。 漫画を書く時なんかは特にこれを知っているか知らないかでだいぶ差が出そうな気がしました。\n理論と実践で学ぶ「魅力的なポーズの描き方」 ~2時間でわかる【ポーズの定理】~｜ライヴポケット\n『ポーズの定理』とは 漫画家・篠房六郎先生の著書です。書籍自体はかな前にたまたまtwitterで知って、同人版を購入していたのですが、長くてなかなか読みきれず、前半軽く目を通して積んでしまっていました。オンライン講座は著者自らが2hにわたってポイントを紹介・解説してくれるとのことで、これはもう参加するしかない次第でした。\n参加メモ 私が思い出す用です。\n1. 基本手首は小指側に倒れる 壁に手をつくと腕は斜めに倒れる 足首も脱力すると内側にまがる。それによりくるぶしの位置が内側の方が高くなる 男女で傾向の違い(描き分けのポイント) 男子は膝もつま先も外向き。ひじは外側 女性は膝を正面に、つま先を内側に。ひじは内側に入る 2. 肩甲骨の動きで背骨も傾く 左右の肘の位置が上下に離れていると、体が傾く 両腕の内、肘の位置が後ろにある方に、背骨は傾きやすい ひねりの話 かばんを持つサンプルと、合気道の動画で紹介 肘の位置と合わせて捻りも意識すると良い 3. 立ち直り反応 人がこけた時の動きのパターンの話 意識がある人は、頭が上がる。それに伴い上半身と肘もついてくる 意識がない人は頭が下に下がる 首を左右に振ったときに目線は水平にならない 左右に触れた時は顎が上がる。後頭部の重心に引っ張られるため 下にあるものを拾おうとする時、頭と体は垂直にならず、肩の低い方に向かって後頭部を倒す形になる 体制を斜めの状態で固定しようとした時、首だけ低い方に倒れ、後頭部の重心は上に向かって後頭部を残す形でバランスを保とうとする 肩と後頭部の位置の関係。首を描くときは首自体と頭の付け根の二か所で稼働を考えると良い 股関節に関して、軸足側の腰が上がる形になる 4. ABCパターン 良いとされるポーズは、基本的には以下のパターンになることが多い。\nA. モデル立ちの時は、肩と反対の腰が上がる B. 前屈みの時は、同じ側の肩と腰が上がる。（ヒーロー着地のような） 角度によって正中線が斜めなのに、真っ直ぐ見えてしまうことがある。 見分け方は、腰、腹がどちらに開いているのか。重心の向きが後ろか前かで、A.Bパターンを当てはめて逆算が可能になる C. A,Bの例外。片足で立った場合、腰は高い方に倒れ込む AとBの複合 美少女を描くときは基本CAパターンが良いらしい 公開添削 走っている人の絵 全力で走ると腕が開く 一番手足が振り切っているときは、宙に浮いている状態の時になる 背骨の剃り 手が後ろに振り切っている時、手は脱力状態になる 猫耳イラスト 篠房先生的にも結構難しいポーズだった。考えながら描いたこととしては、Aパターンだから上がる腰と手は反対の方向になるはず、など 前傾のポーズだったため、腰が見えにくい。そのため見えないから捨てるという判断をしたり 肘が内側に入っていると、手は小指側ではなく内側に向く Q\u0026amp;Aメモ ポーズの定理は手癖に陥らないようにするためのものでもある。定理に忠実に描くことにより一時期は硬くなることもあるが、覚えると描けるものの域が広がってくるはず。(守破離の守) 体の練習方法に関して、パーツを足していくのではなく、全体を割っていくように描くと、バランスよく描ける チェック項目としてポーズの定理がある その他感想 開催はzoomで、進行はKADOKAWAの編集者の人が行う形でした。普段はIT系の勉強会くらいしか参加したことなかったので、進行が雰囲気や大分異なり、新鮮でした。 スライドは最小限で、アジェンダなどあるもののそこにきっちりと言うよりは、篠房先生のipadを黒板に、思いついた方向に話が進むことも多かったです。良くも悪くも緩い感じで。\n同人版はpdfなのですが、ページ数多い割には目次などもないので読みづらく、講座の中で紹介されていた書籍版の中身は結構良い感じに見やすくまとまっていそうだったので、そのうち買い直そうかと思いました。\n","date":"2023-02-26T14:19:45+09:00","permalink":"https://reiichii.github.io/post/2023-02-26-14/","title":"『ポーズの定理』イラスト講座 参加ログ"},{"content":"年末なのでふりかえりをしていました。\n今年立てていた目標のこと 2022年は以下3つの目標を立てていました。\nイラスト上達 ISUCON出場 読書する習慣を取り戻す イラストに関しては、今年一番注力していたものでした。基本スタイルとしては平日朝の始業までの時間で描いており、気の向くままに描きたいものを書き散らしつつ、気になったところを補っていく形です。\nやってよかったものとしては100日チャレンジでした。私はものすごく筆が重く、今までは1人+簡単な背景に10h以上かかっていたのですが、1日1枚描くのを100日続ける！を試してみたところ、3,4h程度で同じクオリティを出せるようになりました。また枚数も少ない時は1ヶ月1枚しか完成しなかったものが、100日チャレンジ期間中は1ヶ月30枚仕上げることができ、人間やればできるものだなと実感したものでした。1枚に掛けられる時間は以前よりも少なくなったのですが、大ラフ〜線画までのトライ\u0026amp;エラーのサイクルを早く回せるようになったおかげか、ベースのクオリティも今年前半と比べるとだいぶ良くなったように見えます。ただ1日1枚はやっぱり厳しく、日常生活に支障をきたすようになってきたので100日は続きませんでした笑\nただそれでもまだ筆は重いし、描くことは辛いです。今年ほどは時間は割けないかもしれませんが、イラストは自分の心の支柱となりつつあるので、来年も楽しくマイペースに続けていきたいです。\nISUCONに関しては、今年初出場することができました。\n0次予選(ただの申し込み)が3回あって本当に助かりました\u0026hellip;。仕事でバタバタしている時期だったので2回申し込みそびれて、出場すらできませんでしたというオチになりかけていたのですが、幸い3回目はすんなり申し込めました。ただ肝心の結果は散々でした。\n今年は手に馴染んだPythonでの出場だったのですが、サーバサイドエンジニアとして幅を広げたいというのもあり、来年はGoで出て結果を残すことが目標です。\n読書する習慣を取り戻すに関しては、私は普段電車の中で本を読んでいたのですが、コロナ禍でリモワに突入して以降本を読まなくなってしまったので立てたものでした。\n結論から言うと、決まった時間に読むといった形での習慣化はできていないのですが、気になる本を見つけて、ちょこちょこ時間を作って年17冊ほどは読むことはできました（仕事関係、小説などジャンルはまちまち。漫画は含まない）。ブクログにつけ忘れることが多々あったので、記録化も合わせて来年以降も続けていきたいです。話題になっていた三体シリーズは読んで本当によかったです。外伝シリーズはまだですが、2巻以降の本編はあっという間でした。\n仕事のこと 仕事面では、今年1年は自分にとっては非常に大きな手応えを得ることができました。\n今年の頭は今のチームに移動して1年くらい経った頃で、一通りの通常業務やシステムへの理解を深められた一方で、未だ漠然とした不安を抱えていたように記憶しています。そんな中先輩社員との1on1の中で「何やりたい？」と聞かれた時にふわっとベースで「設計」と言っていました。それがきっかけで「ビジネス側へのヒアリング→用件定義とシステム設計に落とし込む→実装→テスト→リリース」までを一通り任せてもらえ、そんなサイクルを4回くらい回していました。今までシステム設計以上のフェーズにはほとんど携わったことがなかったのですが、一通りのサイクルを所々チームメンバーにサポートをしてもらいつつも、自分の考えや判断ベースで進めることができて通用することを実感でき、社会人になって以来抱えていた漠然とした不安の大半を解消することができたように思えます。実際会社の評価も2回連続で良いものでした。ただ、今のまま行くとソフトスキルばかり求められるような気がして、それが最近新しい悩みになりつつあります。\nテクニカルスキル面もプライベートでちまちま気になったことを勉強していましたが、特に平日夜は疲れていて思うように時間を確保できなかった時期が多々ありました。今年イラストにかけていた分、来年はこちらの比重を増やし、自分が満足できるアウトプットをより多く出していけたらと思います。\nおわりに 今年からの試みの一つとして、以下を行なっていました\n目標とそのためにやることを管理するためのボードを作って、取り組みと成果を追う Googleカレンダーにやっていたことの時間を大まかにつけ、discordに個人メモを残す 2をしていたおかげで、注力していること以外にどんなことをしていたかを見返すことができました。ふりかえる前は「今年はイラスト以外はイマイチだったな」という所感だったのですが、やってみようと思ったこと、何週間か続いたけどいつの間にかやめていたこと(日記をつけるとか、朝ラジオ体操するとか)、定着し過ぎていて意識から漏れていたこと(メモがとっ散らかっていたので情報を記録する場所をNotionとDiscordと2つに決めてそれのみで行うとか)細かいことが大半ですが、自分が思っていたよりは色々なことをしていました。些細な取り組みも塵積になると侮れないことを実感したので、また来年も上手くいかないことばかりだったとしても、めげずにやっていこうと思いました。\n今年ならではの出来事としては、解散したガネクロのイベントに行けたり、住宅ローンの審査があったり、ガンダムシリーズ(主に宇宙世紀シリーズ)にハマったり、福島に嫁いだ妹の家に遊びに行ったことが特に印象深かったです。\n来年は二十代ラストの年なのですが、歳をとることへの不安というよりは、歳を重ねるごとに人生良くなってきている実感があるので、この調子で楽しくやっていけたらなと思います。ただ首や肩の凝り、肉体面に関しては最近危機感が増しているので、そこらへんは今の内になんとかしたいところ\u0026hellip;🙂\n","date":"2022-12-29T12:23:40+09:00","permalink":"https://reiichii.github.io/post/2022-12-29-12/","title":"さよなら2022年"},{"content":"cliを作りたかったというよりは、FastAPIの兄弟ツールTyperを触ってみたかったのと、Pythonでcliを作る流れを思い出したかったのが動機です。ですのでtodolistは最小限の機能だけを持っています。\n最後にcliを作ったのはPython初めて1年目くらいの頃で、その頃はまだPoetryも触っておらず、setup.py書くの大変だったという記憶しかなかったのですが、今はこんなに手軽に作れてしまうんだなと感動でした。\nPoetryでパッケージを作成する Poetryでプロジェクトの雛形を作成します\npoetry new python_cli_todo . ├── README.md ├── pyproject.toml ├── r_todolist │ └── __init__.py └── tests └── __init__.py 作成したライブラリに必要なパッケージをインストールします。\npoetry add typer[all] 今回はTyperだけです。\npyproject.tomlにcli用の設定を追記\n[tool.poetry.scripts] todo = \u0026#34;r_todolist.main:app\u0026#34; todoコマンドで動くようになっています\nサンプルコードを載せておく\n動作確認をした後実装する予定なので、今は公式ドキュメントの以下のコードを配置しておきます。\nhttps://typer.tiangolo.com/tutorial/package/#create-your-app\n仮想環境内でcliを実行してみる\npoetry install $ poetry run todo load Loading portal gun $ poetry run todo shoot Shooting portal gun アプリケーションの実装 今回実装するtodolistはCRUD4つのサブコマンドを持つものです。DBはSQLite3を使います。各サブコマンドの細かい出力例はREADMEに記載してあります。\nadd: タスクの追加 ls: タスクの一覧参照(デフォルトで未完了のもの・オプションで完了済みのものを表示できる) done: 完了したタスクを完了済みにする rm: タスクの削除(複数指定可) Typerについて https://typer.tiangolo.com/\nFastAPIの作者が作ったcliを作成するためのライブラリになります。作者曰く兄弟ライブラリとのことで、FastAPIの要素である「型定義してエディタのサポートを受け開発効率を上げる」をcli開発時にも実現する設計思想のようです。ただしPydanticではなくClickパッケージをベースに実現させているようでした。\n他にもcli出力時にstyleを良い感じにしてくれるrichというライブラリや、パッケージをインストールしたときに自動で実行環境のシェルに合う形で自動補完設定を追記してくれる機能がついていたりなど、色々充実していました。\n以下ではTyper周りの部分だけ抜粋する形で取り上げています。コードの全体はmain.pyの1ファイルに全部収まっています。\naddサブコマンド import typer from rich import print app = typer.Typer() @app.command() # 1 def add( task: str = typer.Option( # 2 ..., prompt=True, # 3 help=\u0026#34;what you have to do.\u0026#34;, show_default=\u0026#34;send a email\u0026#34;, ) ): \u0026#34;\u0026#34;\u0026#34; add task to list \u0026#34;\u0026#34;\u0026#34; # 4 db.insert_task(task) print(\u0026#34;[green]added.[/green]\u0026#34;) # 5 @app.command() でサブコマンドを関数として定義できる Typerの基本的な挙動として、関数の引数にデフォルト値を含めなければcli実行時の必須のパラメータになり、デフォルト値を指定すればcli実行時のoptionを作ることができる 例えばadd関数の例では、上記の定義をすれば --task というoptionが使えるようになっており、--taskで指定した値がtask変数に渡される 今回はoptionで指定しているが、デフォルト値を省略しているため必須項目としてhelpの表示が出たり、バリデーションが走るようになっている typer.Option()や typer.Arguments()を使えば、引数により詳細な設定を追加することができる 例えばprompt=Trueにしていることで、この関数ではtaskの入力を対話形式で入力できる helpパラメータで、--helpした時にこのオプションの説明を追加することができる docstringで定義した文章は、--help時にそのままサブコマンドの説明として表示される richライブラリの機能で、文字を緑色で表示させる。 lsサブコマンド import typer from rich import print app = typer.Typer() @app.command() def ls(done: bool = typer.Option(False, help=\u0026#34;Show only DONE tasks.\u0026#34;)): # 1 \u0026#34;\u0026#34;\u0026#34; show incomplete tasks. \u0026#34;\u0026#34;\u0026#34; task_lists = db.get_lists(done) for l in task_lists: is_done = \u0026#34;\\[x]\u0026#34; if l.is_done else \u0026#34;[]\u0026#34; # 2 print(f\u0026#39;- {is_done} {l.id}. \u0026#34;{l.task}\u0026#34;\u0026#39;) lsサブコマンドのデフォルトの引数を False に設定している。この定義をした時点で --done というoptionが使えるようになっており、これを指定するとTrueが渡される markdownのチェックボックス形式でタスク一覧を表示させるようにしたかったが、[x]のように書いてしまうとrichの機能と競合して表示されなかった doneサブコマンド @app.command() def done( id: int = typer.Argument( # 1 ..., help=\u0026#34;Select task id\u0026#34;, metavar=\u0026#34;TASK_ID\u0026#34;, show_default=\u0026#34;1\u0026#34; # 2 ) ): \u0026#34;\u0026#34;\u0026#34; check the task \u0026#34;\u0026#34;\u0026#34; task = db.done_task(id) print(f\u0026#39;{task.id}. \u0026#34;{task.task}\u0026#34; is done:tada:\u0026#39;) # 3 task_idが必須項目になるので typer.Argument(...)で定義した metavarパラメータでhelpの表示時を指定できる。また関数のデフォルト値ではなく、helpに表示するときのデフォルト値をshow_defaultで変えられる richの機能で絵文字が表示させることができる rmコマンド @app.command() def rm( ids: List[int] = typer.Argument( # 1 ..., help=\u0026#34;Select task_ids separated by spaces.\u0026#34;, show_default=\u0026#34;1 2\u0026#34;, metavar=\u0026#34;TASK_ID\u0026#34;, ) ): \u0026#34;\u0026#34;\u0026#34; delete the tasks \u0026#34;\u0026#34;\u0026#34; db.delete_ids(ids) print(f\u0026#34;removed: {\u0026#39;,\u0026#39;.join([str(i) for i in ids])}.\u0026#34;) スペース区切りで入力したcliの引数値を、配列として渡すことができる PyPIへ公開する PyPIへログインし、API tokenを発行する\nちなみにAPI tokenを発行する際にはscopeを選択するのですが、プロジェクトがない状態だと全プロジェクトしか選択できません。ただプロジェクトをpublishした後にプロジェクトの管理画面からスコープをプロジェクトに限定したAPI tokenが発行できるようでした。\nPoetryにPyPIのAPI tokenを設定する\n$ poetry config pypi-token.pypi {API TOKEN} publishする\npoetry publish --build publishしたらもう公開されており、pip installでインストールできるようになっています。また更新はpyproject.tomlで設定しているversionを更新して再度同じコマンドを実行する必要があります。\nhttps://pypi.org/project/r-todolist/ 🎉\n参考 Building a Package - Typer ","date":"2022-10-10T12:30:14+09:00","permalink":"https://reiichii.github.io/post/2022-10-10-12/","title":"TyperとPoetryでcliを作って公開するまでの流れ"},{"content":"買ってまだ見ていないライブDVDをホテルに篭って鑑賞したいなー🥺🥺🥺そしてできれば大浴場と美味しい朝食も付いていて欲しいなー🥺🥺というところから始まり、有給取って行ってきました。\nただ残念ながら部屋にプロジェクターが付いていて、且つ持ち込みのDVDを再生できて、且つ大浴場が付いて、且つ一人二人用の部屋というのは探した限りでは見つからず、大浴場を諦めることにしました。\nただ偶然にもホテルから徒歩圏内で行けるところに銭湯があり、大浴場ではないもののサウナがあって温泉が沸いているとのことで結果的にほとんど叶いました。\nホテルに籠ってライブDVDを観る会✌️部屋スタイリッシュで超綺麗だった。狭いけど正方形なので全然圧迫感なく、住める。リクライニングベッドとスクリーンの上下を備え付けのiPodで操作できたり。これなら冷房と照明もできるようにして欲しかった笑 pic.twitter.com/fZ073wTy2D\n\u0026mdash; れ (@reiichii01) September 6, 2022 行ったホテルはこちら。\nちょっとした問い合わせは全部公式サイトのチャットで済むのも便利で良かった。また行きたい。\n銭湯は歩いて5分ほどのところにある政之湯というところ。\n建物は古くシャワーヘッドは動かず浴槽は小さいのですが、清潔感があって天井高くて居心地は良かったです。何よりサウナが付いていて(後から作られたのか綺麗だった)、川崎天然温泉なる黒い湯が沸いていました。\n15:00 チェックイン 買い出し ライブDVD1本目鑑賞 銭湯行く 散歩がてらドミノピザ(徒歩10分)まで歩いて夕飯調達 ライブDVD2本目鑑賞 寝る 起きる ホテルのカフェで朝食 読書 11:00 チェックアウト な具合で巣篭もり満喫できて満足でした☺️\nプロジェクターやDVD再生機器が必要なければ、スクリーンと大浴場(しかも温泉)と朝食付いたこちらのホテルに行きたかった。\nまた別の機会に。\n","date":"2022-09-06T22:20:50+09:00","image":"https://reiichii.github.io/post/2022-09-06-22/IMG_8438_hu4858278573ce4ed581962d459c2ca03b_1191585_120x120_fill_q75_box_smart1.jpg","permalink":"https://reiichii.github.io/post/2022-09-06-22/","title":"プロジェクター付きホテルと温泉で優勝してきた"},{"content":"前回の記事の続きです。\nISUCON12 予選の解説 (Node.jsでSQLiteのまま10万点行く方法) : ISUCON公式Blogを参考にPythonで解き直していました。アプリケーションサーバを分ける手前まで改善したのですがmax6500点までしかいかず、分けても10万点どころか予選突破相当の24000点に届くかさえ怪しかったので頓挫しました。\n追加で実施できたもの\ntenantDB player_scoreにINDEXをはる Ranking APIでランキング集計するのをやめる 自分で追加で行ったこと\nscoreエンドポイントのトランザクション見直し Finish APIでBillingReportを生成する の修正 lockによるエラーが多発したので一旦timeoutを伸ばす players/addの改善 実施しなかったもの\nAddTenant APIでSQLite DBを作るのをやめる nginxで複数台に振り分ける nginxをupstream keepaliveする MySQLをちょっとチューニングする scoreエンドポイントのトランザクション見直し 整合性チェック時に3回に1回くらいの頻度でエラーが発生していたので修正に着手しました。 AUTOCOMMITの設定がちゃんと効いていなかった模様。sqlalchemyはデフォルトでautocommitが効いており、scoreの時だけ設定を上書きするようにしました。\nコミットログ\nエラー解消が目的だったのでスコアに影響はありませんでした。\n参考\nTransactions and Connection Management — SQLAlchemy 1.4 Documentation SQLAlchemyのautocommitについて - Qiita Finish APIでBillingReportを生成する の修正 整合性チェックは通るのですがベンチマーク全体の中で1~3回ほど GET /api/organizer/billing 請求レポートの数が違います (want: 5, got: 1)のようなエラーが出る。 のようなエラーが出る状態でした。\n終わっていない大会の情報も出してあげる必要があったのですが、それらの情報がDBには存在していないのが原因でした。存在しなければscore等を0を入れてレスポンスデータを生成します。\nコミットログ\n上記二つを行なってエラーもなくなり、スコアが安定するようになりました。ただし負荷走行中にSQLite3でlockエラーが多発するようになりました。\ntenantDB player_scoreにINDEXをはる 初期化時にinitial_dataをtenant_db配下にコピーしているのでinitial_dataのテーブルに対してINDEXを追加します。 テナントごとにdbがあるのでシェルでまとめて適用してあげます（ブログに書いてあったコマンドをそのまま実行しました）\nクエリ：create index idx_score on player_score (tenant_id, competition_id, player_id);\nfor db in *.db; do echo \u0026quot;CREATE INDEX...\u0026quot; | sqlite3 $db; done\nちなみにplayer_score以外のテーブルはデータ量が100件程度しかなく、貼っても意味なさそうなのでそのままにしました。 SQLite3の実行計画は クエリの頭にEXPLAIN QUERY PLAN を付けます。\n# player/\u0026lt;player_id\u0026gt;時 EXPLAIN QUERY PLAN SELECT c.title AS title, p.score AS score FROM player_score AS p INNER JOIN competition AS c ON c.id = p.competition_id WHERE c.tenant_id = ? AND p.player_id = ? ORDER BY c.created_at ASC # 結果 |--SCAN p |--SEARCH c USING INDEX sqlite_autoindex_competition_1 (id=?) `--USE TEMP B-TREE FOR ORDER BY 点数は500点ほど上がったのですが、それ以上にDBのlockによるエラーがひどく、41%失点している有様でした。\nlockによるエラーが多発したので一旦timeoutを伸ばす タイムアウトを伸ばすしか思い浮かばなかったのでデフォルト値を調べてみることにしました。\nソースコードを見た感じPythonのSQLite3の標準ライブラリの設定がそのまま反映されているようでそれが5sでした。 30sに設定してみたところlockによる500エラーは大幅に減らせました。ただしclient側でconnection timeoutが発生しているのですがひとまず1件程度まで抑えられたので一旦よしとしました。\nコミットログ\nRanking APIでランキング集計するのをやめる ranking APIの呼び出される回数とscoreが入稿される回数は10～20倍くらい差がある rankingはscoreを入稿したときしか変わらない\n言われてみれば確かに。\n大会中にこのボトルネックに気づいていたらまず間違いなくDELETE+bulk insertで対処していたと思うのですが、 ON DUPLICATE KEY UPDATE を初めて知ったのでこっちで実装してみることにしました。\nON DUPLICATE KEY UPDATE ON DUPLICATE KEY UPDATE を指定した時、UNIQUEインデックスまたは PRIMARY KEY に重複した値を発生させる行が挿入された場合、mysqlによって古い行の値が実行される 存在していればupdate する やることとしては以下です。\nrankingテーブルを作成する CREATE TABLE ranking ( `tenant_id` BIGINT UNSIGNED NOT NULL, `competition_id` VARCHAR(255) NOT NULL, `rank` INT NOT NULL, `score` BIGINT NOT NULL, `player_id` VARCHAR(255) NOT NULL, `player_display_name` TEXT NOT NULL, PRIMARY KEY (`tenant_id`, `competition_id`, `rank`) ) ENGINE=InnoDB DEFAULT CHARACTER SET=utf8mb4; row_numは不要だから消したと思われる。competition_idさえ分かればtenant_idはなくても良さそうに思える scoreエンドポイントでrankingを生成し、insertする 初期化対応 が必要とのことでしたが、データを入れ直さなくてもベンチマークが通ったのでしませんでした。データが溜まっていってしまうのを防ぐために削除だけ行うように修正しました。 コミットログ\nベンチマークを何度か実行していたのですが6500~5600と振り幅が大きい\u0026hellip;。\nplayers/addの改善 alpの結果を眺めていたら上記エンドポイントが異常に重たくなっていました。スコアログを見返すとflockをトランザクションにしたあたりからずっとひどい状態でした笑\nスコアが伸び悩んでいたのもあり、気になったので改善してみようとコードを読んだら、こちらもfor文の中で逐一クエリが発行されていました。sqliteの負荷が懸念だったのもあり以下のようにそれぞれまとめて取得してPython側で頑張るように修正しました。\nコミットログ\nalpを見た感じ改修の効果は得られた(25s→2sになった)のですが、点数には影響せず\u0026hellip;。\nおわりに 10万はいかなくとも2万くらいはいきたいなと思っていたのですが、今のまま複数台分散してもそこまで上がる見込みがなく、だれてきてしまったのもあり一旦一区切りにしようと思います😓\n全体の改善のログは以下に。\nスコア推移のログ · Issue #1 · reiichii/isucon12q-after\nISUCON11予選問題解説のやり方を参考に残していました。\n","date":"2022-09-04T22:28:00+09:00","permalink":"https://reiichii.github.io/post/2022-09-04-22/","title":"ISUCON12予選問題解き直し2"},{"content":"8月はISUCON12 予選の解説 (Node.jsでSQLiteのまま10万点行く方法) | ISUCON公式Blogを見ながらISUCON12予選問題の解き直しをしていました。まだ全部施策をやり切れておらず、点数も上がりきってはいないのですが、1ヶ月経ったので途中までまとめることに。\n実施できたもの\nadminDB visit_history にINDEXを張る dispenseIDでMySQLを使うのをやめる Ranking APIのループクエリをなくす Score APIの追加のループクエリをなくす アトミック書き込みのためのflockをトランザクションに変更する(※怪しい) adminDB visit_historyの初期データをコンパクトにする db用サーバを投入し、2台構成にする Finish APIでBillingReportを生成する(※怪しい) Player APIをなんとかする まだできていないもの\ntenantDB player_scoreにINDEXをはる Ranking APIでランキング集計するのをやめる AddTenant APIでSQLite DBを作るのをやめる nginxで複数台に振り分ける nginxをupstream keepaliveする MySQLをちょっとチューニングする 半分以上は実施しているのに未だ点数が6000点代という\u0026hellip;思ったより厳しかった。\nadminDB visit_history にINDEXを張る 去年の問題ならinitialエンドポイントテーブルが作り直しているのでschemaにindexを追加していたのですが、今回は対象テーブルではdrop createは実行されていないのでここに書いても意味なかったという🙂\ncovering indexという概念を初めて知りました。indexって貼れていればいいと思っていたのですが、張り方によっても性能(点数)に差が出てしまうんですね。せっかくなので3パターンで実行計画を比較してみました。\n# 既存 EXPLAIN SELECT player_id, MIN(created_at) AS min_created_at FROM visit_history WHERE tenant_id = 1 AND competition_id = \u0026#39;S\u0026#39; GROUP BY player_id; +----+-------------+---------------+------------+------+---------------+---------------+---------+-------+---------+----------+------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+---------------+------------+------+---------------+---------------+---------+-------+---------+----------+------------------------------+ | 1 | SIMPLE | visit_history | NULL | ref | tenant_id_idx | tenant_id_idx | 8 | const | 1292937 | 10.00 | Using where; Using temporary | +----+-------------+---------------+------------+------+---------------+---------------+---------+-------+---------+----------+------------------------------+ # covering index +----+-------------+---------------+------------+------+-----------------------------+---------------+---------+-------------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+---------------+------------+------+-----------------------------+---------------+---------+-------------+------+----------+-------------+ | 1 | SIMPLE | visit_history | NULL | ref | tenant_id_idx,idx_all_cover | idx_all_cover | 1030 | const,const | 1 | 100.00 | Using index | +----+-------------+---------------+------------+------+-----------------------------+---------------+---------+-------------+------+----------+-------------+ # createdなし +----+-------------+---------------+------------+------+-----------------------------+---------------+---------+-------------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+---------------+------------+------+-----------------------------+---------------+---------+-------------+------+----------+-------+ | 1 | SIMPLE | visit_history | NULL | ref | tenant_id_idx,idx_all_cover | idx_all_cover | 1030 | const,const | 1 | 100.00 | NULL | +----+-------------+---------------+------------+------+-----------------------------+---------------+---------+-------------+------+----------+-------+ indexを追加すると、possible_keys,keyにidx_all_coverが追加され、filteredが100%になる covering indexにすると、ExtraにUsing indexが表示される createdありとなしではスコアには200点ほど差がでた mysqlのconvering indexとは\nクエリーによって取得されたすべてのカラムを含むインデックス 検索を索引内で完結でき、表からデータを読み取る必要がないため効率が良い 表のサイズがメモリに保持しきれないほど大きい場合の検索で有効 +500点ほど\ndispenseIDでMySQLを使うのをやめる 一意なidを生成するために以下のようにわざわざDBにアクセスしているが、これをuuidを生成するようにする\nコミットログ\nSQLのREPLACE INTOとは\n基本INSERTと同じだが、テーブル内の古い行にprivary keyまたはuniqueインデックスに関して新しい行と同じ値が含まれている場合その古い行は新しい行が挿入される前に削除される 挿入 or 削除と挿入　の違い raise fromについて\n例外を連鎖することができる try: raise ConnectionError() except ConnectionError as e: raise RuntimeError(\u0026#34;Failed to open database\u0026#34;) from e 出力は以下：The above exception was the direct cause of the following exception Traceback (most recent call last): File \u0026#34;~/ghq/github.com/reiichii/isucon12q-after/tmp.py\u0026#34;, line 2, in \u0026lt;module\u0026gt; raise ConnectionError() ConnectionError The above exception was the direct cause of the following exception: Traceback (most recent call last): File \u0026#34;/~/ghq/github.com/reiichii/isucon12q-after/tmp.py\u0026#34;, line 4, in \u0026lt;module\u0026gt; raise RuntimeError(\u0026#34;Failed to open database\u0026#34;) from e RuntimeError: Failed to open database from を使わないと、During handling of the above exception, another exception occurred のようになる +200点ほど\nRanking APIのループクエリをなくす リクエストの合計時間が一番長い /api/player/competition/\u0026lt;competition_id\u0026gt;/ranking をなんとかする。\nN+1になっているのでjoinを使う。\nコミットログ\n+1000点になりました😳\nScore APIの追加のループクエリをなくす rankingの次にレスポンスタイム合計が大きいのはscoreなので\nNode.jsで解いていたブログ記事では上記のように書いてあったが、私の環境(Python)ではscoreよりも/api/player/player/\u0026lt;player_id\u0026gt; の方が重かったです。\n自分では最後のinsertのところをbulk insertにすればいいのかなと思っていたが、存在しないplayer_idを返す必要はないので数を比較するだけで十分という考えには至れませんでした。\nコミットログ\nこちらも+1000点ほど\nアトミック書き込みのためのflockをトランザクションに変更する(※怪しい) 既存コードではテナントDB更新の際に、排他制御をするためにファイルをロックすることをしていますが、トランザクションを使うようにします。 delete-insertの部分をトランザクションにしてflockを外す。他のflockは参照のみなので外すだけで良かった。\nコミットログ\nこの部分を実装したところ、数回に1回整合性チェックが通らなくなりました😢おそらくトランザクションがちゃんと効いていない模様で、なんでか全然分からなかったのですがおそらくAuto Commitが効いてしまっているところに思い至ったのでこれから確認する段階です。\nそしてなぜか点数はそれほど上がらないどころか実行するたびに数百点の振り幅が出るように。\nadminDB visit_historyの初期データをコンパクトにする アプリケーションの作りがアクセスしたかどうかが分かればいいため、visit_historyのテナントID、大会ID、プレイヤーIDをgroup byしてmin(created_at) / min(updated_at)のデータのみが残るようにして重複したデータを減らす。\nちなみに対象テーブルのMySQLの初期化の部分は以下のようになっていて、一定のデータが消えないようになっています。\nDELETE FROM visit_history WHERE created_at \u0026gt;= \u0026#39;1654041600\u0026#39;; 念の為既存データを残しておきたかったので、私は以下の手順で実施しました。\n一時テーブルを作成（visit_history_tmpとする） INSERT SELECT INSERT INTO visit_history_tmp SELECT player_id, tenant_id, competition_id, MIN(created_at), MIN(updated_at) FROM visit_history GROUP BY 1,2,3; 古いテーブルをrename RENAME TABLE visit_history TO visit_history_backup; 一時テーブルをvisit_historyにrename RENAME TABLE visit_history_tmp TO visit_history; 初期化時点の行数：3,224,839 → 削減後のデータ数：200,474（0.06%にまで削減された）\nただし私の場合スコアは変わらず\nDB用サーバを投入し、2台構成にする ブログの方では複数台構成準備のための施策に突入するのですが、私は先にappとdbの二台構成にすることにしました。\nmysqlで他サーバからのアクセスを許容する CREATE USER `isucon`@`192.168.%` IDENTIFIED BY \u0026#39;isucon\u0026#39;; GRANT ALL PRIVILEGES ON `isuports`.* TO `isucon`@`192.168.%`; application側で参照先dbを変更 今回はdocker-composeにホストが書いてあったのでそこの値を変更する 前のベンチマークの時点でCPUが余っていたので、これやっても点数が大して変わらないのは予想通りでした。\nFinish APIでBillingReportを生成する 今回の当日マニュアルにあった、「Finish APIを呼び出したあとにAdmin/OrganizerのBilling APIに結果が反映されるまで3秒の猶予があるの意味は、「初期実装だとBilling APIで請求額を計算しているけど、大会ごとにfinishするときに大会の請求額が確定するので、BillingReportをそこで生成してストレージにいれてね!」です。\n分からん\u0026hellip;😇\nfinish が呼ばれた時にbilling_report_by_competitionを呼び出して、その結果をinsertします。\nテーブルを作成 CREATE TABLE `billing_report` ( `tenant_id` BIGINT UNSIGNED NOT NULL, `competition_id` VARCHAR(255) NOT NULL, `competition_title` VARCHAR(255) NOT NULL, `player_count` BIGINT NOT NULL, `visitor_count` BIGINT NOT NULL, `billing_player_yen` BIGINT NOT NULL, `billing_visitor_yen` BIGINT NOT NULL, `billing_yen` BIGINT NOT NULL, PRIMARY KEY(`tenant_id`, `competition_id`) ) ENGINE=InnoDB DEFAULT CHARACTER SET=utf8mb4; finish apiの時にbilling_report_by_competitionを呼び出して結果をinsertする admin/organizationのbillingの参照先をdbからselectして取ってくる 初期データ生成処理を改修 初期データを入れ直したあとに全ての終了済み大会について billingReportByCompetition を実行してINSERTしなおす必要がある billing report初期データ生成スクリプトを作成 mysqldump -uroot -proot isuports billing_report \u0026gt; initial_billing_report.dump initial時に初期データをimportさせる コミットログ\nスコアはそれほど変わらず、不安定さが増してしまったように見受けられました。(編集とは関係ないエンドポイントでエラーが発生する) ただapi/admin/tenants/billing, api/organizer/billingの呼び出し回数と合計レスポンスタイムが大幅に改善されているので一旦よしとします。\nPlayer APIをなんとかする 上記のメトリクスを眺めているときにPlayer APIがものすごく重たくなっている(MAX 5s程度だったものがMAX 30sになっていた笑)ことに気づき、あまりにも気になったので先に直すことにしました。\nコミットログ\nこれもN+1を直すだけです。必要な情報に対して多くクエリを発行しているのでスリムに書き直してあげます。\n今まで4000点代で伸び悩んでいたスコアが6000点台まで届きました👏\nおわりに スコアが伸び悩んで、また他のことをやりたくなってきたのもあり、8月いっぱいで一旦やめにしようかなと思いかけていたのですが、月末の週に突入して解決の兆しが見えてきたので、もう少し粘ってみようかと思います。\n複数台構成にしたら10万点まで届くのだろうか\u0026hellip;\n続きも書けたら書きます。\n","date":"2022-08-27T14:57:37+09:00","permalink":"https://reiichii.github.io/post/2022-08-27-15/","title":"ISUCON12予選問題解き直し"},{"content":"ISUCON12予選に参加しました。結果は散々だったのですが振り返りも兼ねて残しておこうと思います。\nISUCON12 オンライン予選、17:00の時点でスコアは凍結されました🚀 残時間 01:00:00のスコアはこちら！ #isucon pic.twitter.com/SGjrF9nBCR\n\u0026mdash; ISUCON公式 (@isucon_official) July 23, 2022 ステータス 初出場 Python 1人チーム 2502点 目標は「闇雲に手を動かずに爪痕残す」でした。 爪痕は残せませんでした🪦\n準備 やっていたこととしては以下です。\nISUCON11予選過去問解く alpやmysqlのslow query logなどの計測ツールを使えるようになっておくこと 6月に行われた事前講習とハンズオンへの参加 普段rubyさわらないので多少やりにくかったのですが、出て良かったです。 ISUCON用ansible playbookを用意 計測ツールの導入をスムーズに行うため準備していました タイムライン 09:40~ 配信視聴 予選問題の概要を聞く 10:00~ 開始 ポータルサイト一通り見る（感動した） 当日レギュレーションを読む マニュアルを読む 読みながらアプリケーションを触ったり、ユースケース図を書いて仕様を把握 サーバへのssh接続確認 11:00~ 準備 ソースコードをgit管理下に置く 初回ベンチマークを実行 フワッと改善の目星をつける サーバ構成をmysql用サーバとapplication用の2台構成に変更する 12:00~ 準備 計測ツールの導入 nginxの設定ファイルをgit管理下に配置し直す 13:00~13:30 お昼休憩 20分でご飯食べて10分昼寝。もうこの時点で結構疲れていた 午前中はアプリケーションコードをほとんど見れていない 13:30~ 準備の延長戦 nginxの設定ファイルを間違えており、修正箇所探しに時間を潰す 14:00~ 改善開始 アプリケーションのコードを眺める 14:30~16:30 改善案1.スロウクエリを潰す試み 16:30~17:30 改善案2.リクエスト数の多いエンドポイントの改善 17:30~ 改善案3.bulkinsertに書き換えてみる 17:45~ 再起動チェック 18:00~19:00 競技終了・配信で講評を聞く こうして振り返ってみると計測ツールをスムーズに導入できていれば+1hくらいコード読む時間を捻出できていましたね。ansibleを用意していたがちょこちょこ小さいエラーにはまって気がついたら1hほど経ってしまっていました。\n今回の目標が闇雲に手を動かさないだったので、一応自分なりに根拠や狙いを持っていたつもりだったのですが、講評を聞く感じ的が外れていました。\n改善案0.サーバの役割分担 サーバ構成をmysql用サーバとapplication用の2台構成に変更しました。\n初回ベンチ実行時にtopの出力を眺めていたのですが、dbとpythonがcpuを食い潰しあっているように見えたため。先に分けた方が今後変化追いやすいかなと思ったというのもあります。\n分けたことにより+500点ほどスコアが改善しました。goからpythonにしたときに下がった分が元に戻っただけなので実質プラマイ0ですね。\n改善案1.料金集計処理のスロウクエリを潰す試み adminとorg系リクエストの配点が高いこと adminの一覧画面とorgの請求情報一覧画面が異様に重かったこと スロウクエリログで一番重かったクエリが、上記二つのリクエスト時に実行されるクエリだったこと から、この処理を改善すればパフォーマンスが大きく改善するのではと着手することにしました。\nそれ自体は良かったのですが、 処理が参照しているデータ源がmysqlとsqliteに分かれていることからどうしたら良いものかと手が動かず。sqliteをmysqlに載せ替えるといった選択肢は効果が見込めるかどうか分からなかったので実施に踏み切れませんでした。\nmysql側の改善をしようと検索件数を必要な分だけに絞ったりしていたのですが、ベンチマーカーによる整合性チェックでエラーが出てしまいました。この処理の改善に2hほどかけてしまっていたので中断することにしました。\nログ\n改善案2. playerのリーダーボード一覧エンドポイントを改善する試み alpでリクエストを集計したところ合計レスポンスタイムが一番多かったのはplayerのリーダーボード一覧エンドポイントだったこと ベンチマーカーの出力に「leaderboardの表示に1秒以上かかったため2人の参加者が離脱しました。」のように出ていたこと player系エンドポイントは、先ほどのadminやorg系エンドポイントと異なり加算は少ないのですが、上記の理由からここを改善すれば少なくともスコアがそれなりに改善される見込みがありました。\nただ参照先がsqliteのデータで、パフォーマンス改善ってどうやるんだと首を捻る羽目に。調べてみたらsqliteにもインデックスの概念があり、DB初期化スクリプトのcreate table sql見たところインデックスは貼られていなかったので試しに貼って見たのですが、ほとんどスコアに影響はありませんでした。\nまだ改善の余地はあったのかもですが、この時点で残り1hを切ってしまっていたため一旦深追いをやめてしまいました。\nログ\n改善案3. forでinsertしている箇所をbulkinsertさせる 残り時間が微妙だったので、ソースコード眺めているときに気になっており、すぐに改善できそうな箇所として /api/organizer/players/add のinsert処理を書き換えようと思いました。実施して見たもののベンチマーカーがこけました。単純に書き換えるだけだと後続処理が意図した形に動かなかくなってしまうことに後から気づきました。\nそもそもアプローチ方法が間違えていたのか、後続処理も合わせてなんとかする余地があったのか、残りが15分と検討する時間がもうなかったので中断しました。\nログ\n問題の所感 「mysqlで準備していたからpostgresqlとかだったらきついな..まあスポンサーにmysqlがいるからないか」とか思っていたらまさかのmysql+sqliteでびっくり auto_incrementのところも何か変なコードがあるなぁとは思っていたのですが、料金表とリーダーボード表示の箇所にばかり気を取られていたので全然見れませんでした 講評で「インデックスを貼ればdbの負荷がひとまずは下がる」ようなことが言われていて、もう少しDB周りを重点的に確認すれば良かったです。見ていた箇所のクエリのインデックスは確認していたつもりだったのですがそうではなく、出てきたスロークエリに対してインデックスが効いているかを見ておくべきでした lockがやたら多いのも気にはなっていたのですが、トランザクションを使う箇所というのが出てきませんでした。ただの知見不足です ユースケース図を書いていたのですが、アプリの全体像を網羅的に把握するのに役立ちました。アプリケーションとdbのやりとり周りも何かしらの方法でスムーズに把握できるようになれると良かったのですが その他感想 ISUCON11予選問題を解いていた時はアプリケーションの使用の仕様が難しく、何やっていいか全く分からない状態でした。それに比べたら今回の問題はまだその辺りの把握はしやすかったです ポータルサイトがどんなものかずっと見てみたかったので感動しました。終わった後速攻で選手用ページが見れなくなってしまい、ベンチマークのログやダッシュボードのスクショを取り損ねてしまいました 終わった後眼精疲労でくたくたで、速攻でpc閉じてしまったのですが、DCの方では感想戦で盛り上がっていて他の参加者のバイタリティの高さを感じました。翌朝読み返していて面白く、復習時の参考にまた読み返そうと思います 集中力は8h意外と持ちました。1h~1h30minにつき5minの休憩を無理やり設けるようにして良かったです おわりに 無念 : 楽しかった！ が 6:4の気持ちです。\nあと目と手と頭が足りないです。本戦一人出場している人の凄さを実感します。私がアプリケーション側でもう少しまともに戦えるようになったら、次回は誰か誘ってみるのもありかもなと思えてしまいました。\n今年もPythonでの本戦出場選手は出なかったのでPythonで狙いたいなと思う反面、業務で触らないgoの勉強の口実にしたいという気持ちのが強いので、来年はgoで10000点以上出すことを目標に出てみたいと思います。ベンチマーカーがgoで書かれていて、その辺りの処理ももう少し読めるようになりたいんですよね。\n運営の皆様、開催ありがとうございました。\nhttps://github.com/reiichii/isucon12-qualify\n計測ログ\n","date":"2022-07-24T14:06:01+09:00","image":"https://reiichii.github.io/post/2022-07-24-14/score_graph_hu1c45c6ba752b88bcb48fca24fcaa2fcb_322845_120x120_fill_box_smart1_3.png","permalink":"https://reiichii.github.io/post/2022-07-24-14/","title":"ISUCON12予選参加した"},{"content":"ISUCON11予選環境構築時、構築したアプリケーションでログインしようとすると「このサイトにアクセスできません」が表示されます。また遷移先urlが「http://localhost:5000/?callback=https://isucondition.t.isucon.dev」のようにおかしな表示になります。\n前提として以下の手順を参考に、クラウド環境にアプリケーションを構築し、トップページが開けるところまでを確認済みです。\nISUCON過去問題の環境を「さくらのクラウド」で構築する | さくらのナレッジ\nやること1. JIA API Mockを起動する アプリケーションマニュアルの末尾に書いてあるのですが、サーバの5000portで一部のリクエストを待ち受けるようになっているみたいです。\n実際urlからも分かる通り、apiのログイン時に5000portに飛ばすようになっています。該当コードは以下です。\nhttps://github.com/isucon/isucon11-qualify/blob/main/webapp/frontend/src/components/Home/Auth.tsx#L6\n自動起動はしないため、マニュアルに書いてある手順でモックのサービスを起動してあげます。\nやること2. ポートフォワーディングの設定 このままだとアプリケーションした際にローカル環境の「localhost:5000」にアクセスされてしまいます。\nローカル環境の5000にアクセスされたら、リモートサーバの5000にアクセスされるようにポートフォワーディングの設定をしておきます。\nssh -A -L 5000:{ip}:5000 {user}@{ip}\nssh接続した状態で「JIAのアカウントでログイン」を押すと、「Sign in with JIA」の画面が開き、ユーザー名とパスワードを入力してログイン後の画面にすすめるようになります👏\nおわりに 分かる人には分かるのかもしれませんが、これは構築手順書に説明があった方が親切なような気がしました。\nちなみにこの辺の仕様について話されているissueも発見しました。完全に理解はしていません..。\nhttps://github.com/isucon/isucon11-qualify/issues/1260\n","date":"2022-07-13T22:21:31+09:00","permalink":"https://reiichii.github.io/post/2022-07-13-22/","title":"ISUCON11-qualifyのログインページが開かなかった"},{"content":"ISUCONハンズオン目的で申し込んだのですが、去年一昨年の事前講習レポートには書いていない内容が盛り込まれていて普通に楽しかったです。\nISUCON12 事前講習 - Speaker Deck\nほぼ資料に書いてあるのですが、記念に手元のメモも残します。\n## 強いチームがしていること * なんとなくで手を動かさない。 - 優勝者インタビューで「何が効いたのかわからない」というチームはいない * デプロイのリードタイムをに1分以上かけない - GUIでgit操作しがちなご時世だけど、gitコマンドを使った方がいいよ * 使い慣れたミドルウェアのconfigを1から書かない - 事前に用意しておく * やったことがないことをやらない - 大会中に実務で触っていないgoに移植しようとしてボロ負けした経験がある なんとなく手を動かすな、仮説をベースに動くことはISUCON以外の仕事でも言える。\n## タイムライン 10:00 * マニュアルとレギュレーションを読む * ブラウザでサービスを見て、アプリケーションを把握する * 各コンポートネントがどう起動されているか、設定やconfigの場所を確認 - init.dかsystemcnfかdockerかなど * 自分が必要なruntimeをさっとインストールできるようにしておく * dbスキーマがどう定義されているか調べる * デプロイ方法を構築する * 使われているミドルウェアの種類とバージョンを調べる - 過去にmemcacheかと思ったらmemcacheのplaginを入れたmysqlでそれがすごく重い、という罠があったらしい * 使っているサーバのスペックを各台調査する - サーバによってスペックが異なるケースがある * ベンチマークを実行する 11:00 * 得点源が何かを確認する * 減点の要因を把握する * プロファイリングツールを入れる * 初期状態の完全なバックアップを作成する - tarで固めておく 12:00 * ちゃんとご飯を食べる * わからないことが出たらリストにしておく * やること、やらないことを明確にする 13:00 * デプロイが1コマンドでできるように * デプロイ→性能計測→プロファイルまで一気通貫で行える仕組みを用意しておく - line_profile - リクエスト単位　どちらも 14:00~17:00 * 1コミット1ベンチマーク * 気にする指標を明確に把握してプロファイルする 17:00 * 再起動試験をする * apmを入れていたら停止する - newrelicのapm止めるの意外と難しかったりする * デバックログの出力を止める * プロファイル用に差し込んだものを止める 18:00 * 作業ログをブログに書く準備をする * 記憶が明確な間に振り返りをする 優勝経験チームの行動をトレスしたタイムラインは、考え方など参考にできるところが多い貴重な資料です。\n前にISUCON11予選過去問に挑戦した時、私の場合マニュアルとレギュレーションを読むだけで1時間はかかったので10:00代きっっっつて思いながら聞いていました🙂\n### おすすめの練習 * デプロイ方法セットアップ - リポジトリ作って、git initして、チェックインして、deploy * ansibleを最速で回せるようになっておく * ベンチマークから集計を1コマンドでできるようにする - 集計スクリプトを作っておく * サーバの役割変更 - 起動を止める(systemctlならdisableし忘れない)、接続先を変更する * 使いたいツールのインストール - 使いたいツールは一発で入れられるようにする(alp,pt-query-digest) - prebuilt binaryが用意できるなら用意するのも手 もし今年出れるなら、最低限これだけは準備していきたい。\nまた最後に同じ問題5回くらい解くと、新しい発見があって楽しいよといったこともあって、また過去問解き直そうと思いました。\nちなみにまだ参加申し込みできていませんorz\n","date":"2022-06-07T20:56:13+09:00","permalink":"https://reiichii.github.io/post/2022-06-07-20/","title":"ISUCON12事前講習"},{"content":"\n1年ほど前にこしらえた自作キーボードでpc作業を行なっています。\n久しぶりにキーマップを変えようと思ったらびっくりするくらいやり方を忘れており、思い出すのに結構時間が掛かったため未来の自分用に忘備録としてやり方を残しておきます。\n【自作キーボード】Sparrow62を組み立てた\nやること キーマップの設計 キーボードのfirmwareに書き込む キーマップの設計 キーマップの設計は、QMK ConfiguratorというWebアプリからGUIで行います。\n前の設定を読み込ませる KEYBOARDを自分が使っているものに選択する urlからjsonをアップロードするボタンを押下し、keymap.json（以前の設定時にexportしておいたもの）のrowファイルのurlを読み込ませる 画面ぽちぽちでキーマップの配置を変更する 右上のCOMPILEボタンを押下する 右下のFIRMWAREボタンを押下し、hexファイルをダウンロードする 後の作業のために、この画面はまだ閉じないでおく。\n参考：（初心者編）QMK Configuratorを使ってキーマップを書き換えよう - 自作キーボード温泉街の歩き方\nキーボードのfirmwareに書き込む ローカルPCにインストール済みのQMK Toolboxに先ほどのhexファイルを読み込ませ、キーボードのfirmwareに書き込みます。キーボードは左右繋げたままにして、左右それぞれに書き込みをします。\nQMK Toolboxを開く 先ほどダウンロードしたhexファイルを読み込ませる autoreloadにチェックをする キーボードのリセットボタンを1度押下する 書き込みが始まり、「done. thank you. disconnect」の文言が出たら無事成功 反対のキーボードにケーブルを差し、3と4を行う QMK ConfiguratorのTEST KEYBOARDでキーボードのボタンに意図した変更が反映されていることを確認する。\n参考：（初心者編）自作キーボードにファームウェアを書き込む - 自作キーボード温泉街の歩き方\n後片付け QMK Configuratorでjsonファイルをexportしておく（次回また読み込ませるため） PRINT KEYMAPで画像をスクショしておく（稀にボタンの配置がどうなっていたのか見返したくなるため） 上記をkeymapリポジトリに反映させておく おわりに 初回は設定で精一杯で運用(?)のことを全然考えていなかったので、「あれjsonファイル出力してたっけ」「キーマップの画像をスクショしておいたはずなんだけどどこやったっけ」なんてわたわたしていました。githubに上げておけば家からでも会社からでもキーマップ確認できるし、これできっと一安心😌\n","date":"2022-06-05T16:19:27+09:00","image":"https://reiichii.github.io/post/2022-06-05-16/img_keymap_hu50b55d9f2e639c377323533322f7b495_75174_120x120_fill_box_smart1_3.png","permalink":"https://reiichii.github.io/post/2022-06-05-16/","title":"キーマップ変更する時の手順"},{"content":"はてなからHugoで立てたブログに引っ越しました。\n大きな理由としては、以前のブログの見た目が気に入らなかった（カスタマイズのコストが高い）ことと、vscodeとmarkdownでブログ書きたかったというのが主です。\nデプロイ先はNetlifyを使おうか悩んだのですが、ブログの目的がアウトプットの習慣付けが主で、アクセス数稼ぎに力を入れていないことと、普段業務でGitLabを使うことが多かったので、GitHub PagesやCICDをちょっと触ってみたいなというのもあり、ミニマムにGitHub Pagesで始めてみることにしました。後から乗り換えることもできなくはないですし。その場合ドメイン変わってしまいますが個人ブログでリスクもないので気の向くままにやっていく方針で😌\n既存のブログと記事は特にexportせずそのまま残しておく予定です。（もしかしたら戻る可能性もなくはないので）\nこれからもマイペースに続けていきたいと思います。\n以前のブログ\n","date":"2022-05-27T17:01:55+09:00","image":"https://reiichii.github.io/post/2022-05-27-16/IMG_8179_hu05940ea99d8537e6bd20faf24b516d8b_1077440_120x120_fill_q75_box_smart1.jpg","permalink":"https://reiichii.github.io/post/2022-05-27-16/","title":"ブログ引っ越した"}]