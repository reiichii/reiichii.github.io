<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>読書ログ on 日々のあれこれφ(．．)</title><link>https://reiichii.github.io/tags/%E8%AA%AD%E6%9B%B8%E3%83%AD%E3%82%B0/</link><description>Recent content in 読書ログ on 日々のあれこれφ(．．)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 03 Dec 2023 20:46:47 +0900</lastBuildDate><atom:link href="https://reiichii.github.io/tags/%E8%AA%AD%E6%9B%B8%E3%83%AD%E3%82%B0/index.xml" rel="self" type="application/rss+xml"/><item><title>ゲームを題材に学ぶ 内部構造から理解するMySQL を読んだ</title><link>https://reiichii.github.io/post/2023-12-03-20/</link><pubDate>Sun, 03 Dec 2023 20:46:47 +0900</pubDate><guid>https://reiichii.github.io/post/2023-12-03-20/</guid><description>&lt;p>MySQLの内部構造についてもう少し理解を深めたいと本や資料などを探していた。ネットの記事の方が気軽に情報収集できるので、先にそちらを読むことにした。&lt;/p>
&lt;p>&lt;a class="link" href="https://gihyo.jp/list/group/%E3%82%B2%E3%83%BC%E3%83%A0%E3%82%92%E9%A1%8C%E6%9D%90%E3%81%AB%E5%AD%A6%E3%81%B6-%E5%86%85%E9%83%A8%E6%A7%8B%E9%80%A0%E3%81%8B%E3%82%89%E7%90%86%E8%A7%A3%E3%81%99%E3%82%8BMySQL" target="_blank" rel="noopener"
>ゲームを題材に学ぶ 内部構造から理解するMySQL | gihyo.jp&lt;/a>&lt;/p>
&lt;p>上記は2019年の記事でMySQL8系にも対応していた。全8ページあり、1ページもボリュームもそんなになく読みやすかった。1h30minほどで読み切れた。&lt;/p>
&lt;p>以下読んでいた時のメモ&lt;/p>
&lt;pre tabindex="0">&lt;code># 第1章 DBサーバの構造を知ろう！
- RDBMSはページ単位でデータを読み書きする
- インメモリDBはレコード単位でi/oできる
- MyISAMは固定調のシーケンシャルファイルとしてデータが保存される。超えた場合はフラグメンテーションが起きる。トランザクション処理がない。テーブルロックがかかる。更新が行われないマスタデータに利用すると高速化できる可能性がある。
- PKはクラスタードインデックスという形式で格納される(ルート・ブランチ・リーフ)
- 複合キーを使って同時に使うことが多いデータは同じページになる可能性が高くなるため、i/oの高速化が期待できる
- B-Treeインデックス。mysqlで特定のカラム値のある行を素早く見つけるための仕組み
- 通常のインデックスは、キーとアドレスの組み合わせで保存される
- 更新処理で行っていること
- ログバッファ(HDDに遅延書き込み)
- メモリ上のデータを書き換え
- 再起動時にログファイルのデータをHDDに書き込む
- バックアップファイルとそれ以降のログファイルがあれば、最後にコミットされた時点まで復元可能
# 第2章 ゲーム系で確認すべきパラメータ
- OLTP側は小さいページの方が有利になる可能性がある。
- ただし利用されない空白が多くなる
- TEXT、BLOBなどのデータ型は別ページに保存され
- ページサイズが大きいほど、データが細密に充填されメモリやHDDの利用効率が上がるため、大量のデータの処理に向く
- ログファイルが溢れて、HDDへのフラッシュ（実データの書き込み）が大量に起き、サーバの負荷が高くなる
- innodb_flush_log_at_trx_commit: ログファイルへの書き込みを1sに1回、などに設定できる。書き込み負荷を減らすことに貢献する。デフォルトはコミットごとの書き込み。最大1sデータをログファイルに書き込まれたデータをロストするリスクもある。またバッファが足りなくなったら、1s立たなくても書き込みが行われないことがある
- innodb_buffer_pool_size: 各処理が行える量以上に割り当てないようにしつつ、できる限り大きく取る。目安はキャッシュヒット率99~95%。
# 第3章 実行計画を見てSQLの構造を理解しよう
- sqlはDBエンジンの中のオプティマイザが手続型のソースに翻訳してコンパイルして実行するという処理で行われる
- データと分散具合によってアルゴリズムが変わる
- DBエンジンはヒット率を予想するために事前に統計情報を作っている
- 統計情報が更新されるとき
- インデックスが全体の数%書きかわったとき
- ランダムにインデックスの数ページを選んで統計情報を作成する
- oracleは実行計画が精密だが、更新のパフォーマンスが高い
- joinの順番を変えても実行計画は変わらない。使われているテーブルと結合条件が同じであれば
# 第4章 NoSQLとSQLの使いどころを知ろう
- memcacheとHandlerSocket(mysqlをKVSとして使用できるプラグイン)で処理速度の比較の例。今回の実験ではHandlerSocketの方が早かった
- 処理時間のほとんどがネットワーク処理とsqlのオーバーヘッドで費やされている傾向にあった
- NoSQLを使うと集計処理をDB側でできないためN+1のような非効率な処理になりうる
- NoSQLの方がMySQLよりも早いと言われるが、適材適所。ユーザアクションに対して1件のレコードだけを処理する」機能が多ければNosqlの方が適している可能性がある
# 第5章 DB側でやること、アプリ側でやることを見極めよう
- シンプルなクエリを大量に発行する処理(N+1)はsqlのオーバーヘッドとネットワークの処理が無駄に繰り返されるだけなので、パフォーマンス向上にも寄与しない
- アプリケーション鯖で肩代わりできる処理は、キャッシュやソート(ページャーがない)処理くらいしかない
- DBサーバから大量のデータをAPサーバにすべて値渡しして処理するより、DBサーバ内でできる処理は参照渡しで処理するほうが効率が良い
# 第6章 DBサーバでゲームの処理を作るとどうなる？
- MySQLのストアドプロしーじゃはプリコンパイルされないため、case式の方が高速
- さらに速度を追求する場合はUser Defined Function
# 第7章 パーティショニング
- 多くの処理で抽出条件に指定されるカラム（ゲーム系ではユーザIDなど）がある場合、レスポンスやサーバの負荷削減に効果が高い機能
- MySQLでは、サブパーティションまで作成できる
- MySQLでは、パーティショニングキーになるカラムは、プライマリーキー、または、ユニークキーの一部である必要がある
- 外部キー制約がついているテーブルはパーティショニングができない」という制限がある
- 種類
- ハッシュ: 整数値のカラムの値を分割する個数で割った余りの値で分割する
- キー
- レンジ: 保持期限で削除したい場合、DELETE文で削除するとインデックスの更新処理などが必要になるため非常に時間がかかりますが、レンジパーティショニングにしておけば、不要なパーティションをDROP文で捨て去ることができる
- リスト: Languege = &amp;#39;jp&amp;#39;などカーディナリティの低いカラムで分割
# 第8章 （最終回）　まとめ―
- 集合のイメージを持つ
&lt;/code>&lt;/pre></description></item><item><title>プログラマー脳 ~優れたプログラマーになるための認知科学に基づくアプローチ を読んだ</title><link>https://reiichii.github.io/post/2023-04-09-10/</link><pubDate>Sun, 09 Apr 2023 10:27:16 +0900</pubDate><guid>https://reiichii.github.io/post/2023-04-09-10/</guid><description>&lt;p>『プログラマー脳 ~優れたプログラマーになるための認知科学に基づくアプローチ』と言う本を読んだ時のメモです。&lt;/p>
&lt;blockquote class="twitter-tweet">&lt;p lang="ja" dir="ltr">積み本そっちのけで読む &lt;a href="https://t.co/6XuNOV4aXs">pic.twitter.com/6XuNOV4aXs&lt;/a>&lt;/p>&amp;mdash; れ (@reiichii01) &lt;a href="https://twitter.com/reiichii01/status/1630138659428274176?ref_src=twsrc%5Etfw">February 27, 2023&lt;/a>&lt;/blockquote>
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8">&lt;/script>
&lt;h2 id="きっかけ">きっかけ&lt;/h2>
&lt;p>Goを勉強している時や仕事の中で、なんとなくコーディングに苦手意識がありました。そんな折にたまたまこの本を知って、息抜きがてら読んでみました。&lt;/p>
&lt;h2 id="ざっくりとした感想">ざっくりとした感想&lt;/h2>
&lt;p>自分の場合、脳への負荷が高くなると思考が停止してしまうことが多いのですが、そんな時に今の作業や状態をなるべく小さい単位で把握できると、どこが課題なのかどう対処できそうか考えを進めることができるので、それを実践していきたいと改めて思いました。本の各章に様々な課題に役に立ちそうなtipsが残っていたので、そういった状況に直面したタイミングで、使えそうだなと思ったものをちゃんと思い出せるようにしたいです。&lt;/p>
&lt;p>本に出てくる「チャンク化」や「メンタルモデル」のなどは、コーディング以外のところではやっている自覚はあって、ただ自分ではそういうことをしているという自覚はなかったので、無意識だったものを言語化して把握することができました。&lt;/p>
&lt;p>他にもオンボーディングの話や、初学者と熟練者の取り組み方の比較など書いてあったので、自分よりも若手の人に教えたりする機会にも役に立ちそうな内容が多く含まれていました。&lt;/p>
&lt;p>複数人に対してどんな風に変数の命名をするか課題を出して結果を比較するなど、プログラミング関連の研究事例が多数紹介されていたのも面白かったです。世の中にこんな研究している人たちがいることを知って目から鱗でした。&lt;/p>
&lt;h2 id="内容">内容&lt;/h2>
&lt;p>とりわけ印象に残っているところを中心に、自分が思い出す用途のものです。ただ内容をしっかり説明できるほど理解はできていないので、一旦そう言うものがあるのかも程度に留め、必要に応じて該当箇所を読み返したいです。&lt;/p>
&lt;h3 id="第1章-コードをよりよく理解するために">第1章 コードをよりよく理解するために&lt;/h3>
&lt;p>この章ではコーディング時に発生する認知負荷についてどんなものがあるのか、またそれらがどう影響し合っているのか、それらを踏まえてコードを読みやすくするためにできる工夫などが書かれていた。&lt;/p>
&lt;ul>
&lt;li>コードを読む時の認知負荷
&lt;ul>
&lt;li>知識不足&lt;/li>
&lt;li>情報不足&lt;/li>
&lt;li>処理能力の不足&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>記憶のチャンク化
&lt;ul>
&lt;li>ビーコンなど、記憶を容易にする工夫をすると良い&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>負荷が高いと感じる時に、何によるものなのか自分が把握できると良いのかもと思った。&lt;/p>
&lt;h3 id="第2章-コードについて考える">第2章 コードについて考える&lt;/h3>
&lt;p>この章では第1章の認知負荷の話を踏まえて、コードをより理解するためのアプローチ方法について書かれていた。&lt;/p>
&lt;ul>
&lt;li>変数の役割11パターン
&lt;ol>
&lt;li>固定値&lt;/li>
&lt;li>ステッパー：ループ処理の際に使われるiのようなもの&lt;/li>
&lt;li>フラグ&lt;/li>
&lt;li>ウォーカー：ステッパーと同様にデータを走査する際に使用されるが、ステッパーのように何が入るか予測しにくいもの。配列のインデックスだったり、ポインタだったり&lt;/li>
&lt;li>直近の値の保持者：例えばファイルから読み込んだ行など&lt;/li>
&lt;li>最も重要な値の保持者：反復処理の中などで目的の値を保持するもの&lt;/li>
&lt;li>収集者：データを一つの変数に集約させている時に使うもの&lt;/li>
&lt;li>コンテナ：リストや配列など、複数要素を保持するもの&lt;/li>
&lt;li>フォロワー：アルゴリズムなどで、前や次の値を保持して、他の変数とセットで利用されるもの&lt;/li>
&lt;li>オーガナイザー：値を並べ替えたり、異なる形式で保存するためだけに使われるもの&lt;/li>
&lt;li>テンポラリ：短期間だけ使われるもの&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>コードを読む際にも適用可能な文書理解の戦略
&lt;ul>
&lt;li>活性化：関連する事柄を積極的に考え、過去の知識を活性化させる&lt;/li>
&lt;li>監視：理解度を把握し続ける&lt;/li>
&lt;li>重要性の判断&lt;/li>
&lt;li>推論&lt;/li>
&lt;li>可視化&lt;/li>
&lt;li>自問自答&lt;/li>
&lt;li>要約&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>メンタルモデル&lt;/li>
&lt;li>より良い変数名のための3ステップ
&lt;ul>
&lt;li>命名に含める概念を選択する&lt;/li>
&lt;li>概念を表す単語を選択する&lt;/li>
&lt;li>単語を使って命名を行う&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>変数の役割11パターンは自分考えたことなかったけど、言われてみれば役割は何パターンかに集約されそう。&lt;/p>
&lt;h3 id="第3章-より良いコードを書くために">第3章 より良いコードを書くために&lt;/h3>
&lt;p>この章では理解しやすいコードを書くにはどうするか、またその逆として理解しにくいコードにはどういう特徴があるか、といった内容が書かれていた。&lt;/p>
&lt;ul>
&lt;li>コードの臭い
&lt;ul>
&lt;li>「巨大なクラス」や「長過ぎるメソッド」など、リファクタリング本で取り上げられているものが紹介されていた&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>範例（work example）。問題解決能力を養うには、公式だけではなく、公式を使ってどうやって解いたかも合わせて教えてもらったグループの方が点数が高くなる傾向にあると言う教育系の研究事例がある。&lt;/li>
&lt;/ul>
&lt;p>リファクタリング本は読もうと思っていて積んでいたので、内容を少し知れて参考になった。&lt;/p>
&lt;p>今までの章を読んでこの章を読むと、分かりやすい命名によって受けられる恩恵の大きさを再認識できた気がする。&lt;/p>
&lt;h3 id="第4章-コーディングにおける共同作業">第4章 コーディングにおける共同作業&lt;/h3>
&lt;p>この章では開発者個人からさらに視野を広げて、チームで開発する際に新しい人が参画しやすくする方法などについて書かれていた。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>プログラミングの中の様々な活動&lt;/p>
&lt;ul>
&lt;li>転写&lt;/li>
&lt;li>探索&lt;/li>
&lt;li>理解&lt;/li>
&lt;li>検索&lt;/li>
&lt;li>増強：検索・理解・転写を組み合わせて新しい機能を作ること&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>コードの理解のしやすさの指標&lt;/p>
&lt;ul>
&lt;li>エラーの発生しやすさ&lt;/li>
&lt;li>一貫性&lt;/li>
&lt;li>拡張性&lt;/li>
&lt;li>隠された依存関係&lt;/li>
&lt;li>暫定性&lt;/li>
&lt;li>粘性&lt;/li>
&lt;li>段階的評価&lt;/li>
&lt;li>役割表現力&lt;/li>
&lt;li>マッピングの近接度&lt;/li>
&lt;li>ハードな心的操作&lt;/li>
&lt;li>副次的表記&lt;/li>
&lt;li>抽象化&lt;/li>
&lt;li>視認性&lt;/li>
&lt;/ul>
&lt;p>表記法の認知特性（cognitive dimentions of notation）と言うものを、コードを対象に拡張したもの。ただしこれらは全部を満たせれば良いと言うものではなく、トレードオフの関係になるものもある。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>新人のオンボーディングにあたって、認知負荷が高いことを覚えておく必要がある。熟練者は習得にかかった負荷を忘れてしまうもの&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>エンジニア1年目の自分は熟練のプログラマーは頭の中で全てコーディングを完結させているものだと思っていたので、1年目の自分にこれを教えてあげたかった。&lt;/p></description></item><item><title>ドメイン駆動設計入門(SoftwareDesign2023年2月号)を読んだ</title><link>https://reiichii.github.io/post/2023-02-27-15/</link><pubDate>Mon, 27 Feb 2023 14:52:15 +0900</pubDate><guid>https://reiichii.github.io/post/2023-02-27-15/</guid><description>&lt;p>Software Design2月号で特集されていたドメイン駆動設計入門を読んだ時のメモです。&lt;/p>
&lt;h2 id="きっかけ">きっかけ&lt;/h2>
&lt;p>直近のタスクで作ったコードの設計がなんとなくいまいちで、どうすればもっとよくできていたのか悩んでいました。
また少し読んでいたGoの本で出てきたAPIのリポジトリ構成の設計思想がクリーンアーキテクチャやDDDがベースになっているもので、この辺り理解を深めたいなと思っていました。
そんな折にたまたま雑誌を見つけたので買って読んでみた次第です。&lt;/p>
&lt;h2 id="ざっくりとした感想">ざっくりとした感想&lt;/h2>
&lt;p>ちゃんと学びたいのであれば本当は原点の本にあたるべきなのですが、分厚く内容も古いため、雑誌の方が効率よく概要を把握できたような気がします。
特に本では説明されていない、クリーンアーキテクチャのような他の設計との関係性など、実用的な追記されているのが良いところでした。&lt;/p>
&lt;p>前半1~3章（概要・ドメインモデルの作り方・分散アーキテクチャの設計パターン）まではよかったのですが、4章（開発事例）に関しては説明が腑に落ちなかったり、事例に結果が伴っていなかったりと物足りなさは感じました。
とはいえ前半3章だけでも十分に読む価値はありました。&lt;/p>
&lt;p>思想みたいなものは大分把握できたと思うのですが、実業務にうまいこと導入するところに関してはまだイメージが湧かないので、もう少しいろんな他社事例を見てみれたらと思います。&lt;/p>
&lt;p>余談ですが、分散アーキテクチャの章で紹介されていた書籍「ソフトウェアアーキテクチャ ノードパーツ」読みたい。&lt;/p>
&lt;h2 id="内容">内容&lt;/h2>
&lt;p>主に復習&amp;amp;自分が思い出す用。第4章は割愛し、第5章（用語まとめ）は織り交ぜて要所要所に混ぜ込んだ。&lt;/p>
&lt;h3 id="第1章-ドメイン駆動設計とは">第1章. ドメイン駆動設計とは&lt;/h3>
&lt;p>根本の考え方について説明されている章。原点本の内容ベースだが、それにアプリケーション開発・オブジェクト指向・アジャイル開発と絡めた説明を筆者が追記している。&lt;/p>
&lt;ul>
&lt;li>前提としている考え方
&lt;ul>
&lt;li>事業の存続と発展&lt;/li>
&lt;li>それには、成長と変化するソフトウェアが必要になる&lt;/li>
&lt;li>それを実現するためには、複雑な業務ロジックに焦点を当てる必要がある&lt;/li>
&lt;li>そのためにドメインモデルを使う&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ドメイン
&lt;ul>
&lt;li>なんらかのルールに基づいて管理されている範囲&lt;/li>
&lt;li>ソフトウェアが対象とする領域&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ドメイン駆動設計は、ソフトウェアV字モデルの最上位と最深部を強く関連づけることを目標とし、事業活動が発展し、変化を繰り返しながら存続していくことに貢献することを目指している&lt;/li>
&lt;li>ドメインモデル
&lt;ul>
&lt;li>事業の要点を抜き出してわかりやすくしたもの&lt;/li>
&lt;li>活用方法として以下がある
&lt;ul>
&lt;li>業務知識の理解を深める&lt;/li>
&lt;li>用語がバラバラになる問題に対し、同じ言葉で開発できるようにする&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>知識豊富な設計&lt;/code>
&lt;ul>
&lt;li>重要な業務ルールを見極め、関係性を整理するためにドメインモデルを作っていくこと&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>深いモデル&lt;/code>
&lt;ul>
&lt;li>見落としに気付けたり、暗黙的な枠組みを明示的に表現できるようになったドメインモデル&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>これら二つは目指す方向性の認識合わせに必要&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>モデルと実装を結びつけるためのパターン
&lt;ol>
&lt;li>3層構造&lt;/li>
&lt;li>ポート&amp;amp;アダプター&lt;/li>
&lt;li>クリーンアーキテクチャ&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>3は完成コストが高く、それを簡略化したものが1や2という見方もある。上記3つの基本原則は同じ&lt;/li>
&lt;li>分離方法
&lt;ul>
&lt;li>業務ロジックとそれ以外のクラスを分離する&lt;/li>
&lt;li>業務ロジックを表現するクラスだけを、ドメインモデルに置く&lt;/li>
&lt;li>必要であれば両方を合成するクラスを作る（これはドメインモデルの外に置く）
&lt;ul>
&lt;li>これらが混在することはよくあるので、都度リファクタリングをしていく&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="第2章-ドメインモデルを理解しよう">第2章. ドメインモデルを理解しよう&lt;/h3>
&lt;p>ドメイン駆動設計の中心となるドメインクラス設計のやり方について、原点本にも出てくる貨物運搬の予約フローを例にモデルに落とし込むやり方が解説されている。&lt;/p>
&lt;ul>
&lt;li>業務ロジックを記述する方法3つ
&lt;ol>
&lt;li>トランザクションスクリプト
&lt;ul>
&lt;li>入出力手順中心&lt;/li>
&lt;li>▲同じ計算が異なるトランザクションスクリプトに点在。関連する業務ルールが点在しがちになる。複雑なルールの記載は難しい&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ドメインモデル
&lt;ul>
&lt;li>業務ロジックとデータ参照を分ける&lt;/li>
&lt;li>このデータ参照部分をアプリケーションクラス・ユースケースクラスと言ったりする&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>テーブルモジュール
&lt;ul>
&lt;li>CRUDの中に必要に応じて業務ロジックを埋め込む&lt;/li>
&lt;li>▲複数のテーブルをまたぐロジックは埋め込めない&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>事業活動のモデルを作る観点として、以下3つがある
&lt;ul>
&lt;li>観点
&lt;ul>
&lt;li>プロセス
&lt;ul>
&lt;li>フロー図やumlのアクティビティ図に起こす&lt;/li>
&lt;li>この図ではルールの存在を明示できない&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>データ
&lt;ul>
&lt;li>よくあるのは、イベントとリソースに分けてモデリングするやり方&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ルール
&lt;ul>
&lt;li>業務ルールを表現する概念をクラスで表現しながら、業務ルールに基づく計算判断のロジックの置き場所としてメソッドを作る&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>モデル設計の構成要素
&lt;ul>
&lt;li>エンティティ
&lt;ul>
&lt;li>個別に認識できる実態。管理番号を持つ何か。クラスの有力候補&lt;/li>
&lt;li>業務ルールを見つける方法として、エンティティを「イベント」「短命なリソース」「長命なリソース」に分けるやり方がある
&lt;ul>
&lt;li>イベントには2種類のルールが関連する
&lt;ul>
&lt;li>イベント発生に関するルール（許可・禁止）&lt;/li>
&lt;li>行動ルール（記録・通知など）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>値オブジェクト
&lt;ul>
&lt;li>業務ルールに基づく計算判断に使う属性を発勁んし、クラスとして表現するパターン&lt;/li>
&lt;li>値オブジェクトに注目することで、値を使う業務ルールが見つかる&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>コレクションオブジェクト
&lt;ul>
&lt;li>配列・集合・写像などインスタンス変数としてもち、それを使う操作ロジックを同じクラスに集める&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>区分オブジェクト
&lt;ul>
&lt;li>場合分けを整理するのに使う。Enumで表現されるような&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>モジュール
&lt;ul>
&lt;li>エンティティやオブジェクトなど、数あるクラスをわかりやすく整理するパターン。パッケージや名前空間となる&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="第3章-分散アーキテクチャとドメイン駆動設計">第3章. 分散アーキテクチャとドメイン駆動設計&lt;/h3>
&lt;p>分散アーキテクチャとドメイン駆動設計がどう絡むかを、原点本ベースにした内容が紹介されている。&lt;/p>
&lt;ul>
&lt;li>単一モデル
&lt;ul>
&lt;li>従来のソフトウェア設計では、事業活動全体をこれで考えていた。しかしそれによって全体の構造が固定され、柔軟性や発展性が失われていった&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>分散モデル
&lt;ul>
&lt;li>自立して活動する複数の構成要素が動的につながって、ネットワークを構成している&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ドメイン駆動設計が提供する分散アーキテクチャのモデルには、以下の3パターンがある
&lt;ol>
&lt;li>境界づけられたコンテキスト
&lt;ul>
&lt;li>1つのドメインが対象とする範囲を限定するアプローチ&lt;/li>
&lt;li>これによって、業務の目的や関心事が異なる領域を切り分ける。ユビキタス言語の適用範囲になる&lt;/li>
&lt;li>コンテキスト(文脈)：言葉の意味は文章の前後によって決まる。ドメインモデルを作るときは言葉の意味が同じになる範囲を切り分ける、が発想元&lt;/li>
&lt;li>必ずしも分散アーキテクチャの範囲となるわけではない&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>コンテキストマップ
&lt;ul>
&lt;li>1の中だけで意味を持つ複数のドメインモデルをどう繋げるかを検討するパターン&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>コアドメイン
&lt;ul>
&lt;li>2が増えた時に、複雑な全体の中で中核になる要素に焦点を合わせ、全体に秩序を生み出す&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>マイクロサービス化する際に考えなければいけないこと
&lt;ul>
&lt;li>サービス間の繋ぎ方
&lt;ul>
&lt;li>通信はDBに比べて遅く不安定なので、検知やリトライの仕組みが必要になる&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>データの共有
&lt;ul>
&lt;li>同じデータを参照する仕組みのやり方色々
&lt;ul>
&lt;li>必要な情報を都度問い合わせる&lt;/li>
&lt;li>共有のためのサービスを作る&lt;/li>
&lt;li>情報を複製（キャッシュ）する&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>コンテキストマップを複雑にする要因はチーム間の関係性
&lt;ul>
&lt;li>関係性のパターン
&lt;ul>
&lt;li>対等
&lt;ul>
&lt;li>パートナーシップ&lt;/li>
&lt;li>共有カーネル&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>偏りがある
&lt;ul>
&lt;li>顧客と供給者&lt;/li>
&lt;li>順応者&lt;/li>
&lt;li>腐敗防止層&lt;/li>
&lt;li>公開ホストサービス&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>断絶した関係&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>サービス間調整のやり方
&lt;ul>
&lt;li>API仕様の公開&lt;/li>
&lt;li>テスト仕様の公開
&lt;ul>
&lt;li>仕様を一種の契約と見做して、双方が満たすことに責任を持つ&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>テスト環境の提供
&lt;ul>
&lt;li>提供側の負担は大きいが、問題の早期発見につながる&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>コアドメインに集中する
&lt;ul>
&lt;li>事業領域の全体にドメイン駆動設計のやり方を適用するのは、現実的ではないので、集中すべきところを絞る&lt;/li>
&lt;li>集中すべきところ
&lt;ul>
&lt;li>業務プロセスやルールが複雑な箇所&lt;/li>
&lt;li>独自性のある箇所&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>コアドメイン以外の対処法
&lt;ul>
&lt;li>既製品を使う。契約管理など&lt;/li>
&lt;li>イージーオーダー&lt;/li>
&lt;li>フルオーダー&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>進化する秩序&lt;/code>
&lt;ul>
&lt;li>コンテキストやつなぎ方は日々進化していくため、秩序を整えていく必要がある&lt;/li>
&lt;li>&lt;code>責務のレイヤー&lt;/code>
&lt;ul>
&lt;li>上記を実現する手段の一つ。1つのドメインの中でパッケージの役割を分類し、パッケージ間の依存関係を整理する&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ドメインモデルを中核としたアプリケーションを動かすパターン
&lt;ul>
&lt;li>ユースケース（アプリケーション）
&lt;ul>
&lt;li>アプリケーションが必要とする計算判断を「集約」が提供するが、それを使って計算判断を実行する役割のクラス&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ファクトリー
&lt;ul>
&lt;li>複雑な集約を生成する役割のクラス&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>リポジトリ
&lt;ul>
&lt;li>ユースケースが記録や参照に使う役割のクラス&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item></channel></rss>